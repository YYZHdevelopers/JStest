<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>原型对象</title>
		<script type="text/javascript">
			
			function Person(name,num,gender){
					this.name=name;
					this.num=num;
					this.gender=gender;
					this.sayHello=fun;
			}
			function fun(){
				console.log("学号："+this.num);
				console.log("姓名："+this.name);
				console.log("性别："+this.gender);
			}
			// 将函数定义在全局作用域中，污染了全局作用域的命名空间，而且在全局作用域中也很不安全
			var per =new Person("张三",1101,"男");
			per.sayHello();
			// 引入原型 prototype
			// 我们所创建的每一个函数，解析器都会向函数中添加prototype，这个属性对应着一个对象，这个对象就是所谓的原型对象。
			
			
			function enterUser(){
				
			}
			var en=new enterUser();
			// 如果函数作为普通函数调用prototype则没有任何作用
			// 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性指向该数的原型对象，我们可以通过_proto_来访问该属性
			console.log(enterUser.prototype);
			console.log(en.__proto__);
			console.log(en.__proto__ ==enterUser.prototype );
			// 原型对象就相当于一个公众的区域，所有同一类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容统一社会到原型对象中
			// 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型中寻找，如果找到则直接使用
			function MyClass(){
				
			}
			var mc=new MyClass();
			MyClass.prototype.stuName="张三"; //向对象中添加属性，这个属性是添加到公共区域的
			MyClass.prototype.stuNum=90;
			
			mc.stuName="李四";// 如果直接添加属性还是添加到原区域的	
			console.log(MyClass.prototype);
			console.log(mc.__proto__);
			console.log(mc.stuName+mc.stuNum);
			// 像MyClass的原型中添加一个方法
			MyClass.prototype.sayNname=function(){
				document.write(mc.stuName);
			}
			mc.sayNname();
		/* 
			以后创建构造函数时，将这些对象共有的属性和方法统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加属性，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了
		 */
		
		// 复习使用工厂方法创建对象
		function createCar(carName,carNum){
			var car =new Object();
			car.carname=carName;
			car.carnum=carNum;
			car.carstart=function(){
				alert(car.carname+car.carnum+"起飞");
			}
			return car;
		}

		var car1=new createCar("凯迪拉克",1103);
		car1.carstart();
		console.log(car1);
		var car2=new createCar("特斯拉",1101);
		car2.carstart();
		
		
			
		</script>
	</head>
	<body>
	</body>
</html>
